# Тестовое задание для YADRO

## Запуск и тестирование

Запуск: `go run -v ./... <input-file> <output-file>`

Тестирование: `go test -v ./...`

## Постановка задачи
У Васи есть файл с именами всех жителей Санкт-Петербурга, по одному имени на каждой строке. Вася хотел бы посчитать, сколько раз встречается каждое имя.
```
Пример файла:
Алёна
Миша
Алёна
Дима
```
```
Пример результата:
Миша:1
Алёна:2
Дима:1
```
В результате должна получиться консольная утилита на Go, которая получает имя файла на вход и выдаёт результат пользователю.

## Решение для поставленной задачи

- Выгрузить все имена из файла в один массив
- Отсортировать массив с помощью стандартной функции `sort.Strings(...)`
- Сжать получившийся массив (подряд идущие эквивалентные имена заменить на `[Имя, Кол-во подряд идущих имен]`)


### Минусы данного подхода

- Решение упирается в объем оперативной памяти, требуемой для выгрузки всех имен в массив

## Задания под звездочкой

### Что делать, если файл очень большой?

В данном случае следует написать B+ дерево, так как его блочная архитектура позволяет делать меньше обращенний к памяти и не хранить полностью дерево.

### Можем ли мы выводить имена в порядке убывания частоты?

В случае B+ дерева, реализовать поставленную задачу не получится (разве что построить два раза дерево, сначала string->int, потом int->string).

В предложенном мной решении, есть `.env` файл, в котором задается конфигурация сортировки в виде переменной окружения. Значение переменной окружения `CONFIG` задает название конфигурации для сортировки выходных данных. Файлы конфигурации хранятся в `cmd/config` в виде json-файлов, со следующей структурой:
```json
{
  "type": "<string>",
  "value": "<int>",
  "return": "<bool>",
  "else": {}
}
```
```
"type": "first" - проверка имени, "second" - проверка кол-ва имен
"value": -1 -> a < b, 0 -> a == b, 1 -> a > b
"return": if (compare<"type">(a, b) == "value") return "return";
"else": имеет такую же структуру вложенности, переход в нее осуществляется если compare<"type">(a, b) != "value"
```
Данная json-конфигурация представляет собой запись функции высшего порядка. Функция является компаратором для сортировки выходных данных.

### Какие тесты мы можем написать?

Обычные юнит-тесты с actual, expected json-файлами.
Также юнит-тесты с рандомной генерацией и проверкой.